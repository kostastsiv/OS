Koffas Georgios, AEM: 2389 (gkoffas@uth.gr)
Tsivgiouras Konstantinos, AEM: 2378 (ktsivgiouras@uth.gr)
Charatzoglou Michalis, AEM: 2352 (mcharatzoglou@uth.gr)

####### IMPLEMENTATION NOTES #######

* Αποφασίσαμε το filesystem μας να έχει τη μορφή "block storage", με το δωσμένο rootdir να αποτελεί την αποθήκη αυτή. Το filesystem μας είναι volatile, ενώ την metadata πληροφορία για το filesystem την αποθηκεύουμε σε δικές μας δομές στη μνήμη. Ως αποτέλεσμα, το params.h έχει και τα prototypes των δομών αυτών, καθώς και κάποια άλλα χρήσιμα defines.

* Οι συναρτήσεις που χρειάστηκε να μεταβάλουμε για να το πετύχουμε αυτό ήταν:
	1) mknod: Δημιουργεί, όπως και στον αρχίκό κώδικα, ένα κενό αρχείο με το όνομα που του δίνεται ως όρισμα, όμως δεσμεύει και μνήμη για να κάνει store τις πληροφορίες γι αυτό (το όνομα του σε αυτό το στάδιο), ενώ τελικά αυτή η δομή μπαίνει σε μια λίστα η οποία είναι διαθέσιμη για το filesystem για όλο το τρέχον session.
	2) read: Ανατρέχουμε στη λίστα η οποία περιέχει πληροφορίες για τα blocks από τα οποία αποτελείται ένα file, και διαβάζομε τα δεδομένα αυτών των blocks. Δουλεύει και για αρχεία μεγέθους που δεν είναι πολλαπλάσιο των 4KB.
	3) write: Ανατρέχουμε όπως και στη read στη λίστα για την πληροφορία για τα blocks από τα οποία αποτελείται ένα file, και προσθέτουμε σε αυτή τη λίστα τα νέα blocks που θα έχουν διαφορετικό περιεχόμενο από υπάρχοντα blocks στο filesystem.
	4) readdir: Για να μην φαίνονται τα blocks από τα οποία αποτελείται ένα αρχείο στο mounted directory, έχουν συγκεκριμένη ονομασία, και πριν κληθεί η filler συνάρτηση μέσω της οποίας φαίνονται τα περιεχόμενα του directory στο terminal, εντοπίζουμε αυτά τα αρχεία με το συγκεκριμένο όνομα και τα προσπερνάμε
	5) getattr: Για μη φαίνονται σε μια ls -l(R) εντολή τα δημιουργημένα αρχεία ως άδεια, κάνουμε manually set τα πεδία του struct stat τους με τρόπο που το size τους να είναι όσο είναι αθροιστικά το size των blocks από τα οποία αποτελούνται.
	6) unlink: Όταν θέλουμε να διαγράψουμε ένα αρχείο, ή όταν ένα block δεν υπάρχει σαν data σε κάνενα αρχείο, αφαιρούνται από την αντίστοιχη λίστα στην οποία περιέχεται η μετα-πληροφορία για αυτά, και στη συνέχεια διαγράφονται και ως οντότητες από το filesystem.
	8) destroy: Κάνουμε free όλες τις δυναμικά δεσμευμένες δομές πυο χρησιμοποιήσαμε, και με τη βοήθεια 2 συναρτήσεων διαγράφουμε όλα τα περιεχόμενα του rootdir, και στη συνέχεια το ίδιο το rootdir.

####### EXPERIMENT NOTES #######

* Έχουμε φτιάξει ένα bash script το οποίο κάνει όλη τη διαδικασία του compilation, filesystem binary execution και unmounting αυτόματα. Επίσης τρέχει ένα παράδειγμα στο οποίο φτιάχνει ο χρήστης ένα αρχείο κειμένου (όχι binary), και ένα πολύ παρόμοιο αρχείο κειμένου, από τα οποία στη συνέχεια δημιουργούνται 2 αντίγραφα τους. Οι παρατηρήσεις είναι 2: 
	α) Λόγω της διαφοράς τους (όσο μικρή και αν είναι) στα δεδομένα, το hash που αντιστοιχεί σε αυτά τα δεδομένα είναι πολύ διαφορετικό, οπότε τελικά δημιουργούνται διαφορετικά blocks για το κάθε αρχείο, και
	β) Κατά την δημιουργία των αντιγράφων, επειδή τα hashes των blocks που θα δημιουργούνταν είναι ίδια με αυτά από προϋπάρχοντα blocks στο filesystem, δεν ξαναδημιουργούνται νέα blocks, μειώνοντας έτσι τον αποθηκευτικό χώρο που απαιτείται για αυτό το session του filesystem.

* Για να τρέξετε το αρχείο, απλά τρέξτε στο directory που βρίσκονται τα scripts και ο example folder την εντολή 
							./test.sh 
από το terminal.

* Για να δείτε τα συμπεράσματα του πειράματος, μπορείτε να ανοίξετε από έναν text editor το test.log αρχείο που δημιουργείται στον example folder, ο οποίος πρακτικά περιέχει dumped το stdout του terminal, και κάποια μηνύματα για να φαίνεται σε ποιο βήμα του experiment ανήκουν τα dumps.

* ΣΗΜΑΝΤΙΚΟ: Επειδή το script ανοίγει ένα gedit παράθυρο για το γράψιμο των αρχείων, αφού σώσετε τα αρχεία, κλείστε το window για να συνεχίσει η εκτέλεση, και πατήστε "Close without saving" στο prompt που θα εμφανιστεί
